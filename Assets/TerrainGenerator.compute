#pragma kernel GenerateHeightMap

Texture2D<float3> BumpTex;
SamplerState samplerBumpTex;


int heightMapRes;
float time;
float2 offset;
RWTexture2D<float4> heightMap;

float random(float2 st) {
	return frac(sin(dot(st.xy,
		float2(12.9898, 78.233)))*
		43758.5453123);
}

float noise(in float2 st) {
	float2 i = floor(st);
	float2 f = frac(st);

	// Four corners in 2D of a tile
	float a = random(i);
	float b = random(i + float2(1.0, 0.0));
	float c = random(i + float2(0.0, 1.0));
	float d = random(i + float2(1.0, 1.0));

	// Smooth Interpolation
	float2 u = smoothstep(0.0, 1.0, f);

	// Mix 4 coorners percentages
	return lerp(a, b, u.x) +
		(c - a)* u.y * (1.0 - u.x) +
		(d - b) * u.x * u.y;
}

#define OCTAVES 6
float fbm(float2 st) {
	// Initial values
	float value = 0.0;
	float amplitude = .5;
	float frequency = 0.;
	//
	// Loop of octaves
	[unroll(OCTAVES)]
	for (int i = 0; i < OCTAVES; i++) {
		value += amplitude * noise(st);
		st *= 2.;
		amplitude *= .5;
	}
	return value;
}

float pattern(float2 p) {
	float2 q = float2(fbm(p + float2(0.0, 0.0)),
		fbm(p + float2(5.2, 1.3)));

	float2 r = float2(fbm(p + 4.0*q + float2(1.7, 9.2)),
		fbm(p + 4.0*q + float2(8.3, 2.8)));

	return fbm(p + 4.0*r);
}

float pCurve(float x, float a, float b) {
	float k = pow(a + b, a + b) / (pow(a, a)*pow(b, b));
	return k * pow(x, a) * pow(1.0 - x, b);
}


float generateHeight(uint2 id, float2 o) {
	float2 v = 3 * id * (1.0f / heightMapRes) + o;
	float a = fbm(v);
	return a;
}

//#define POINTS 20
//float distort(uint2 id, float2 o) {
//	float2 v = 3 * id * (1.0f / heightMapRes) + o;
//	float2 b = BumpTex.SampleLevel(samplerBumpTex, id * (1.0f / heightMapRes), 0).xy;
//
//	//return fbm(v + fbm(v + time + 5 * fbm(v - float2(1.5, 1.5))));
//	float d = distance(id * 1.0f / heightMapRes, float2(fbm(o), noise(o.x + o.y)));
//	float color = d;
//	for (int i = 1; i <= POINTS; i++)
//	{
//		float c = distance(id * 1.0f / heightMapRes, float2(fbm(o+i), noise(o.x + o.y + i)));
//		if (c < d) {
//			d = c;
//		}
//	}
//	//return fbm(v + o +(1 - d) * fbm((1 - d) * v - float2(1.5, 1.5)));
//	return d;
//}

[numthreads(8, 8, 1)]
void GenerateHeightMap(uint3 id : SV_DispatchThreadID)
{
	float f = generateHeight(id.xy, offset);// +0.5 + 0.5*sin(time);
	heightMap[id.xy] = f; // float4(pCurve(f, 2.0, 0.25), pCurve(f, 6.0, 6.0), pCurve(f, 0.25, 2.0), 1);
}

#pragma kernel GenerateHeights
RWStructuredBuffer<float> heightBuffer;

[numthreads(8, 8, 1)]
void GenerateHeights(uint3 id : SV_DispatchThreadID)
{
	heightBuffer[(id.y * heightMapRes) + id.x] = generateHeight(id.xy, offset);
}

#pragma kernel GenerateNormals
RWTexture2D<float3> nrmMap;


[numthreads(8, 8, 1)]
void GenerateNormals(uint3 id : SV_DispatchThreadID)
{
	//float4 N = float4(
	//	generateHeight(uint2(id.x + 1, id.y), offset),
	//	generateHeight(uint2(id.x - 1, id.y), offset),
	//	generateHeight(uint2(id.x, id.y + 1), offset),
	//	generateHeight(uint2(id.x, id.y - 1), offset)
	//);
	float4 N = float4(
		generateHeight(uint2(id.x + 0.01, id.y), offset),
		generateHeight(uint2(id.x - 0.01, id.y), offset),
		generateHeight(uint2(id.x, id.y + 0.01), offset),
		generateHeight(uint2(id.x, id.y - 0.01), offset)
		);
	float3 nrm = float3(N.y - N.x + 0.02, N.z - N.w + 0.02, 0.02);
	nrmMap[id.xy] = normalize(nrm);
}

#pragma kernel GenerateVerts
RWStructuredBuffer<float3> vertexBuffer;

[numthreads(8, 8, 1)]
void GenerateVerts(uint3 id : SV_DispatchThreadID)
{
	//float4 N = float4(
	//	generateHeight(uint2(id.x + 1, id.y), offset),
	//	generateHeight(uint2(id.x - 1, id.y), offset),
	//	generateHeight(uint2(id.x, id.y + 1), offset),
	//	generateHeight(uint2(id.x, id.y - 1), offset)
	//);
	vertexBuffer[(id.y * heightMapRes) + id.x] = float3(id.y*0.01, generateHeight(id.xy, offset), id.x*0.01);
}

#pragma kernel Erode

#define MAX_LIFETIME 100
#define INERTIA 0.05
#define SEDIMENT_CAPACITY_FACTOR 4.0
#define MIN_SEDIMENT_CAPACITY 0.01
#define DEPOSIT_SPEED 0.1
#define ERODE_SPEED 0.1
#define GRAVITY 6
#define EVAPORATION_SPEED 0.01
#define EROSION_SIZE 8

struct particle 
{
	float2 pos;
	float2 dir;
	float speed; 
	float water; 
	float sediment;
};

RWStructuredBuffer<particle> particles;

float heightAndGradient(in particle p, out float2 gradient) 
{
	int2 coord = int2((int)p.pos.x, (int)p.pos.y);
	int heightIndex = coord.y * heightMapRes + coord.x;
	float2 offset = p.pos - coord;

	// Calculate the particle's height and the direction of flow with bilinear interpolation of surrounding heights
	float4 nh = float4(
		heightBuffer[heightIndex],
		heightBuffer[heightIndex + 1],
		heightBuffer[heightIndex + heightMapRes],
		heightBuffer[heightIndex + heightMapRes + 1]
	);
	//
	gradient = lerp(nh.yz - nh.xx, nh.ww - nh.zy, offset);
	//float2(
	//	lerp(nh.y - nh.x, nh.w - nh.z, offset.y),
	//	lerp(nh.z - nh.x, nh.w - nh.y, offset.x)
	//);

	return	nh.x * (1.0 - offset.x) * (1.0 - offset.y) +
			nh.y * offset.x * (1.0 - offset.y) +
			nh.z * (1.0 - offset.x) * offset.y +
			nh.w * offset.x * offset.y;
}

[numthreads(32, 1, 1)]
void Erode(uint3 id : SV_DispatchThreadID)
{
	particle p = particles[id.x];

	[fastopt] for (int lifetime = 0; lifetime < MAX_LIFETIME; lifetime++)
	{
		int2 coord		= int2((int)p.pos.x, (int)p.pos.y);
		int heightIndex = coord.y * heightMapRes + coord.x;
		float2 offset   = p.pos - coord;

		float2 gradient;
		float height = heightAndGradient(p, gradient);

	// Update the particle's direction and position (move 1 unit regardless of speed so as not to skip over sections of the map)
		p.dir = normalize(p.dir * INERTIA - gradient * (1.0 - INERTIA));
		p.pos += p.dir;
		if (p.dir.x == 0 || p.dir.y == 0 || p.pos.x < 0 || p.pos.x > heightMapRes || p.pos.y < 0 || p.pos.y > heightMapRes)
		{
			break;
		}

	// Find the particle's new height and calculate deltaHeight
		float newHeight = heightAndGradient(p, gradient);
		float deltaHeight = newHeight - height;

	// Calculate the particle's sediment capacity (higher when moving fast down a slope and contains lots of water)
		float sedimentCapacity = max(-deltaHeight * p.speed * p.water * SEDIMENT_CAPACITY_FACTOR, MIN_SEDIMENT_CAPACITY);

	// If carrying more sediment than capacity, or if flowing up a slope:
	//   - deposit a fraction of the sediment to the surrounding nodes (with bilinear interpolation)
		if (p.sediment > sedimentCapacity || deltaHeight > 0)
		{	// DEPOSIT
			float amount =  (deltaHeight > 0) ? min(deltaHeight, p.sediment) : (p.sediment - sedimentCapacity) * DEPOSIT_SPEED;
			p.sediment -= amount;

			heightBuffer[heightIndex] += amount * (1.0 - offset.x) * (1.0 - offset.y);
			heightBuffer[heightIndex + 1] += amount * offset.x * (1.0 - offset.y);
			heightBuffer[heightIndex + heightMapRes] += amount * (1.0 - offset.x) * offset.y;
			heightBuffer[heightIndex + heightMapRes + 1] += amount * offset.x * offset.y;
		}

	// Otherwise:
	//   - Erode a fraction of the particle's remaining capacity from the soil, distibuted over the radius of the particle
	//	   NOTE: don't erode more than deltaHeight to avoid digging holes behind the particle and creating spikes
		else 
		{	// ERODE
			float amount = min(sedimentCapacity - p.sediment * ERODE_SPEED, -deltaHeight);
			for (int y = -EROSION_SIZE; y < EROSION_SIZE; y++)
			{
				for (int x = -EROSION_SIZE; x < EROSION_SIZE; x++)
				{
					int index = heightIndex + (y * heightMapRes + x);
					float weightedErodeAmount = 0.0005; //*(EROSION_SIZE - distance(p.pos, (float2)(coord + int2(x, y)))) / (float)EROSION_SIZE;
					float deltaSediment = min(heightBuffer[index], weightedErodeAmount);
					heightBuffer[index] -= deltaSediment;
					p.sediment += deltaSediment;
				}
			}
		}
	// Update particle's speed based on deltaHeight
		p.speed = sqrt(p.speed * p.speed + deltaHeight * GRAVITY);
	// Evaporate a fraction of the particle's water
		p.water *= (1 - EVAPORATION_SPEED);
	}
}